```cpp
#include <queue>
#include <deque>
#include <vector>
#include <set>
#include <unordered_map>
using namespace std;

#define MAXN 2003

struct Pos { int r, c; };

int N, idCnt, time, dr[] = { -1,0,1,0 }, dc[] = { 0,1,0,-1 };
unordered_map<int, int> hmap;

bool overlap(int minr1, int minc1, int maxr1, int maxc1, int minr2, int minc2, int maxr2, int maxc2) {
    if ((maxr2 < minr1 || maxr1 < minr2) && (maxc2 < minc1 || maxc1 < minc2)) return false;
    return true;
}

set<int> s;

struct worm {
    int mid, id, hr, hc, len, dir, minr, maxr, minc, maxc, potential;
    bool live;
    deque<Pos> dq;
    void initial() {
        dir = 0, minr = hr, minc = maxc = hc, maxr = hr + len - 1, potential = 0, dq.clear(), live = true;
        for (int i = 0; i < len; i++) dq.push_back({ hr + i, hc });
    }
    void move() {
        if (minr == maxr || minc == maxc) ++dir %= 4; // 다음 방향을 더해주고 4로 나눈 나머지를 계산
        hr += dr[dir], hc += dc[dir];
        if (hr < 0 || hc < 0 || hr >= N || hc >= N) { s.insert(mid); return; }
        update(); // hr, hc 추가, minmax rc value update
    }
    void collision() {
        for (auto& nx : hmap) {
            int id2 = nx.second;
            if (id == id2) continue;
            int flag = false; // 충돌가능성
            if (overlap(minr, minc, maxr, maxc, w[id2].minr - 1, w[id2].minc - 1, w[id2].maxr + 1, w[id2].maxc + 1)) // id2의 경우 최대최소보다 1정도 크게 잡아야 함.
                flag = true;
            if (flag) { // 일단 상대방 지렁이의 범위내에 들어왔는지 여부
                if (hr == w[id2].hr && hc == w[id2].hc) { // 머리충돌한 경우 두개 다 삭제
                    s.insert(mid); s.insert(w[id2].mid);
                }
                for (auto& nx : w[id2].dq)
                    if (hr == nx.r && hc == nx.c) {
                        w[id2].potential += len; // 몸통충돌한 경우 현재지렁이(id)만 삭제
                        s.insert(mid);
                    }
            }
        }
    }
    void update() { // update max, min value
        dq.push_front({ hr, hc });
        minr = min(minr, hr), maxr = max(maxr, hr), minc = min(minc, hc), maxc = max(maxc, hc);
        if (minr == dq.back().r || maxr == dq.back().r || minc == dq.back().c || maxc == dq.back().c) { // 끝점이 최대최소값을 가지는 경우
            minr = maxr = hr, minc = maxc = hc;
            if (potential) potential--, len++; // 잠재력이 있으면 길이증가
            else dq.pop_back();
            for (auto& nx : dq) minr = min(minr, nx.r), maxr = max(maxr, nx.r), minc = min(minc, nx.c), maxc = max(maxc, nx.c);
        }
        else {
            minr = min(minr, hr), maxr = max(maxr, hr), minc = min(minc, hc), maxc = max(maxc, hc);
            if (potential) potential--, len++;
            else dq.pop_back();
        }
    }
}w[1003];

void remove() {
    for (int mid : s) hmap.erase(mid);
    s.clear();
}

void init(int N) {
    ::N = N, idCnt = time = 0, hmap.clear(), s.clear();
}

int getID(int c) {
    return hmap.count(c) ? hmap[c] : hmap[c] = idCnt++;
}

void process(int cnt) {
    for (int i = 0; i < cnt; i++) {
        for (auto& nx : hmap) w[nx.second].move();
        for (auto& nx : hmap) w[nx.second].collision();
        remove(); // 지연삭제처리를 해야하므로 필요
    }
}

void join(int mTime, int mID, int mX, int mY, int mLength) {
    process(mTime - time);
    int id = getID(mID);
    w[id] = { mID, id, mY, mX, mLength, true };
    w[id].initial();
    time = mTime;
}

struct Data { int len, mid;};
bool compare(const Data& a, const Data& b) {
    if (a.len != b.len) return a.len > b.len;
    return a.mid > b.mid;
}
struct RESULT { int cnt = 0, IDs[5] = { 0, 0, 0, 0, 0 }; };
RESULT top5(int mTime) {
    RESULT ret = RESULT();
    process(mTime - time);
    time = mTime;
    vector<Data> v;
    for (auto& nx : hmap) v.push_back({ (int)w[nx.second].dq.size(), nx.first});
    int len = (int)v.size();
    if (len && len < 5) sort(v.begin(), v.end(), compare);
    else if (len >= 5) partial_sort(v.begin(), v.begin() + 5, v.end(), compare), len = 5;
    for (int i = 0; i < len; i++) ret.cnt = len, ret.IDs[i] = v[i].mid;
    return ret;
}
```
