```cpp
#define MAX_NUMBER       200001
#define BUY             false
#define SELL            true
#define MAX_STOCK       6 // 1 - 5
#define INVALID_VALUE   0

#include <iostream>
using namespace std;

struct Order {
    int stock;
    int quantity;
    int price;
    bool type;
};

Order orders[MAX_NUMBER];
int owp;

int minPrice[MAX_STOCK];
int maxProfit[MAX_STOCK];

void init() {
    owp = 0;
    for (int oIdx = 1; oIdx < MAX_NUMBER; oIdx++)
    {
        orders[oIdx].quantity = 0;
    }

    for (int i = 0; i < MAX_STOCK; i++)
    {
        minPrice[i] = 1000000;
        maxProfit[i] = -1000000;
    }
}

void conclude(int mBID, int mSID, bool type) {
    //printf("conclude...\n");
    int bIdx = mBID;
    int sIdx = mSID;
    Order buy = orders[bIdx];
    Order sell = orders[sIdx];

    // 체결수량 갱신
    if (buy.quantity < sell.quantity) {
        sell.quantity -= buy.quantity;
        buy.quantity = 0;
    }
    else if (buy.quantity > sell.quantity) {
        buy.quantity -= sell.quantity;
        sell.quantity = 0;
    }
    else {  // buy.quantity == sell.quantity
        buy.quantity = 0;;
        sell.quantity = 0;
    }

    // 체결덮어 씌워주기
    orders[bIdx] = buy;
    orders[sIdx] = sell;

    // 체결 가격 정하기
    int price = -1;
    if (type == SELL)
    {
        price = buy.price;
    }
    else if (type == BUY)
    {
        price = sell.price;
    }
    
    // 최솟값, 최대이익 매번 갱신
    int stock = orders[bIdx].stock;
    if (price < minPrice[stock]) minPrice[stock] = price;
    if (price - minPrice[stock] > maxProfit[stock])
        maxProfit[stock] = price - minPrice[stock];

    return;
}

int getSellOrder(int mStock)
{
    /*
        50
            40
            30
            20
            10(3) 10(2) 10(4)
    */
    //1. 가장 낮은 가격?
    int minPrice = 2000000;
    for (int oIdx = 1; oIdx <= owp; oIdx++)
    {
        //매도 주문인가?
        if (orders[oIdx].type == BUY)    continue; 
        if (orders[oIdx].stock != mStock)    continue;

        //수량체크 필요
        if (orders[oIdx].quantity == 0)  continue;
        
        int price = orders[oIdx].price;
        if (price < minPrice)  minPrice = price;
    }

    if (minPrice == 2000000) return -1;

    // 2. '1.' 주문번호가 가장 낮은 주문?
    int idx = -1;
    int minNumber = 300000;
    for (int oIdx = 1; oIdx < owp; oIdx++)
    {
        //매도 주문인가?
        if (orders[oIdx].type == BUY)    continue;
        // 수량체크 필요
        if (orders[oIdx].quantity == 0)  continue;

        int price = orders[oIdx].price;
        if (price != minPrice)   continue;

        int number = oIdx;
        if (number < minNumber)
        {
            minNumber = number;
            idx = oIdx;
        }
    }
    return idx;
}

// 500원               450원 500원 550원 600원(15)
//                                      600원(13)
//                                      600원(20)

int getBuyOrder(int mStock)
{
    //1. 가장 높은 가격?
    int maxPrice = 0;
    for (int oIdx = 1; oIdx <= owp; oIdx++)
    {
        //매수 주문인가?
        if (orders[oIdx].type == SELL)    continue;
        if (orders[oIdx].stock != mStock)    continue;

        //수량체크 필요
        if (orders[oIdx].quantity == 0)  continue;

        int price = orders[oIdx].price;
        if (price > maxPrice)  maxPrice = price;
    }

    if (maxPrice == 0)   return -1;

    // 2. '1.' 주문번호가 가장 낮은 주문?
    int idx = -1;
    int minNumber = 300000;
    for (int oIdx = 1; oIdx < owp; oIdx++)
    {
        //매수 주문인가?
        if (orders[oIdx].type == SELL)    continue;
        // 수량체크 필요
        if (orders[oIdx].quantity == 0)  continue;

        int price = orders[oIdx].price;
        if (price != maxPrice)   continue;

        int number = oIdx;
        if (number < minNumber)
        {
            minNumber = number;
            idx = oIdx;
        }
    }
    return idx;
}

int buy(int mNumber, int mStock, int mQuantity, int mPrice) {
    // 매수 주문 생성
    int oIdx = mNumber;
    Order o = {mStock, mQuantity, mPrice, BUY};
    orders[oIdx] = o;
    owp = oIdx;

    // 체결 진행
    int bIdx = oIdx;
    int stock = mStock;
    while (1)
    {
        if (orders[bIdx].quantity == 0)   break;

        // 체결이 가능한가?
        int sIdx = getSellOrder(stock);
        if (sIdx == -1) break;
        if (orders[sIdx].price > orders[bIdx].price) break;

        // 체결
        conclude(bIdx, sIdx, BUY);
    }
    // 현재 매수 주문의 남은 수량 반환
    return orders[bIdx].quantity;
}

int sell(int mNumber, int mStock, int mQuantity, int mPrice) {
    // 매도 주문 생성
    int oIdx = mNumber;
    Order o = {mStock, mQuantity, mPrice, SELL};
    orders[oIdx] = o;
    owp = oIdx;

    // 체결 진행
    int sIdx = oIdx;
    int stock = mStock;
    while (1)
    {
        // 현재 매도 주문으로 체결이 가능한 상태인가?
        if (orders[sIdx].quantity == 0)   break;

        // 매수 주문 찾기
        int bIdx = getBuyOrder(stock);
        if (bIdx == -1) break;

        // 찾은 매수 주문으로 체결이 가능한가?
        if (orders[sIdx].price > orders[bIdx].price) break;

        // 체결
        conclude(bIdx, sIdx, SELL);
    }
    // 현재 매수 주문의 남은 수량 반환
    return orders[sIdx].quantity;
}

void cancel(int mNumber) {
    // 지금 들어온 주문번호가 어디 주문인지?
    orders[mNumber].quantity = INVALID_VALUE;
}

int bestProfit(int mStock) {
    return maxProfit[mStock];
}
```
