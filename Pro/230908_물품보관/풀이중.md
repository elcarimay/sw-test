```cpp
#if 1
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <iostream>
#include <cmath>
using namespace std;

inline int max(int a, int b) { return a < b ? b : a; }
inline int min(int a, int b) { return a > b ? b : a; }
inline int ceil(int a, int b) { return (a + b - 1) / b; }

#define MAX_N 100005
#define INF 987654321
int goods[MAX_N];
struct Pair
{
	int idx, value;
};
struct Tree
{
	int sum;
	Pair max, min;
}tree[MAX_N * 4];
struct SegmentTree
{
	void init(int start, int end, int node) {
		if (start == end) {
			tree[node] = { goods[start],{start,goods[start]} ,{start,goods[start]} };
			return;
		}
		int mid = (start + end) / 2;
		init(start, mid, node * 2);
		init(mid + 1, end, node * 2 + 1);
		tree[node].sum = tree[node * 2].sum + tree[node * 2 + 1].sum;
		tree[node].max = { node, max(tree[node * 2].max.value, tree[node * 2 + 1].max.value) };
		tree[node].min = { node, min(tree[node * 2].min.value, tree[node * 2 + 1].min.value) };
	}
	void update(int start, int end, int node, int idx, int diff) {
		if (idx < start || end < idx) return;
		if (start == end) {
			tree[node] = { tree[node].sum + diff, {node,tree[node].max.value + diff},
			{node,tree[node].min.value + diff} };
			return;
		}
		int mid = (start + end) / 2;
		update(start, mid, node * 2, idx, diff);
		update(mid + 1, end, node * 2 + 1, idx, diff);
		tree[node].sum = tree[node * 2].sum + tree[node * 2 + 1].sum;
		tree[node].max = { node,max(tree[node * 2].max.value, tree[node * 2 + 1].max.value) };
		tree[node].min = { node,min(tree[node * 2].min.value, tree[node * 2 + 1].min.value) };
	}
	int sum_query(int start, int end, int node, int left, int right) {
		if (left > end || right < start) return 0;
		if (left <= start && end <= right) return tree[node].sum;
		int mid = (start + end) / 2;
		int sum_left = sum_query(start, mid, node * 2, left, right);
		int sum_right = sum_query(mid + 1, end, node * 2 + 1, left, right);
		return sum_left + sum_right;
	}
	Pair min_pair(Pair a, Pair b) {
		int idx, val;
		if (a.value > b.value)	idx = b.idx, val = b.value;
		else {idx = a.idx, val = a.value;}
		return { idx, val };
	}
	Pair min_query(int start, int end, int node, int left, int right) {
		if (left > end || right < start) return { -1, INF };
		if (left <= start && end <= right) return tree[node].min;
		int mid = (start + end) / 2;
		Pair min_left = min_query(start, mid, node * 2, left, right);
		Pair min_right = min_query(mid + 1, end, node * 2 + 1, left, right);
		return min_pair(min_left, min_right);
	}
	Pair max_pair(Pair a, Pair b) {
		int idx, val;
		if (a.value < b.value)	idx = b.idx, val = b.value;
		else { idx = a.idx, val = a.value; }
		return { idx, val };
	}
	Pair max_query(int start, int end, int node, int left, int right) {
		if (left > end || right < start) return { -1, -INF };
		if (left <= start && end <= right) return tree[node].max;
		int mid = (start + end) / 2;
		Pair max_left = max_query(start, mid, node * 2, left, right);
		Pair max_right = max_query(mid + 1, end, node * 2 + 1, left, right);
		return max_pair(max_left, max_right);
	}
}S;

int N;
void init(int N)
{
	::N = N;
	for (int i = 1; i <= N; i++) goods[i] = 0;
	for (int i = 1; i <= N * 4; i++) tree[i] = {};
}

Pair getMax(int left, int right) {
	return S.max_query(1, N, 1, left, right);
}

int getArea() {
	int ret = 0, cur_loc, prev_loc, cur_height;
	// 전체
	cur = getMax(1, N - 1);
	ret += cur_height;
	
	// 왼쪽
	cur_height = getMax(0, );

	// 오른쪽
}

int stock(int mLoc, int mBox)
{
	goods[mLoc - 1] = mBox;
	S.update(0, N-1, 1, mLoc - 1, mBox);
	int ret = getArea();
	return ret;
}

int ship(int mLoc, int mBox)
{
	return -1;
}

int getHeight(int mLoc)
{
	return -1;
}
#endif
```
