```cpp
#if 1 // 초
#include <queue>
#include <deque>
#include <vector>
#include <set>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
using namespace std;

#define MAXN 2003

struct Pos { int r, c; };

int N, idCnt, time, dr[] = { -1,0,1,0 }, dc[] = { 0,1,0,-1 };
unordered_map<int, int> hmap;
vector<int> s;
long long grid[MAXN/10][MAXN/10];
struct worm {
    int mid, id, hr, hc, len, dir, tr, tc, potential;
    long long minp, maxp;
    deque<Pos> dq;
    inline long long hashPos(int r, int c) { return (long long)r * MAXN + c; }
    void initial() {
        dir = 0, tc = hc, tr = hr + len - 1, potential = 0, dq.clear();
        for (int i = 0; i < len; i++) dq.push_back({ hr + i, hc });
    }
    void move() {
        if (hr == tr || hc == tc) ++dir &= 3; // 다음 방향을 더해주고 4로 나눈 나머지를 계산
        hr += dr[dir], hc += dc[dir];
        if (hr < 0 || hc < 0 || hr >= N || hc >= N) { s.push_back(mid); return; }
        update(); // hr, hc 추가, minmax rc value update
    }
    void collision() {
        for (auto& nx : hmap) {
            int id2 = nx.second;
            if (id == id2) continue;
            long long hp = hashPos(hr, hc);
            int minr = min(w[id2].hr, w[id2].tr), maxr = max(w[id2].hr, w[id2].tr), minc = min(w[id2].hc, w[id2].tc), maxc = max(w[id2].hc, w[id2].tc);
            if (hashPos(minr, minc) <= hp && hp <= hashPos(maxr, maxc)) {
                if (hp == hashPos(w[id2].hr, w[id2].hc)) { // 머리충돌한 경우 두개 다 삭제
                    s.push_back(mid); s.push_back(w[id2].mid);
                }
                for (auto& nx : w[id2].dq)
                    if (hp == hashPos(nx.r, nx.c)) {
                        w[id2].potential += len; // 몸통충돌한 경우 현재지렁이(id)만 삭제
                        s.push_back(mid);
                    }
            }
        }
    }
    void update() { // update max, min value
        dq.push_front({ hr, hc });
        int minr = min(hr, tr), maxr = max(hr, tr), minc = min(hc, tc), maxc = max(hc, tc);
        if (minr == tr || maxr == tr || minc == tc || maxc == tc) { // 끝점이 최대최소값을 가지는 경우
            minr = maxr = hr, minc = maxc = hc;
            if (potential) potential--, len++; // 잠재력이 있으면 길이증가
            else dq.pop_back();
            for (auto& nx : dq) minr = min(minr, nx.r), maxr = max(maxr, nx.r), minc = min(minc, nx.c), maxc = max(maxc, nx.c);
        }
        else {
            if (potential) potential--, len++;
            else dq.pop_back();
        }
        minp = hashPos(minr, minc), maxp = hashPos(maxr, maxc);
    }
}w[1003];

void remove() {
    s.erase(unique(s.begin(), s.end()), s.end());
    for (int mid : s) hmap.erase(mid);
    s.clear();
}

void init(int N) {
    ::N = N, idCnt = time = 0, hmap.clear(), s.clear();
}

int getID(int c) {
    return hmap.count(c) ? hmap[c] : hmap[c] = idCnt++;
}

void process(int cnt) {
    for (int i = 0; i < cnt; i++) {
        for (auto& nx : hmap) w[nx.second].move();
        for (auto& nx : hmap) w[nx.second].collision();
        remove(); // 지연삭제처리를 해야하므로 필요
    }
}

void join(int mTime, int mID, int mX, int mY, int mLength) {
    process(mTime - time);
    int id = getID(mID);
    w[id] = { mID, id, mY, mX, mLength, true };
    w[id].initial();
    time = mTime;
}

struct Data { int len, mid; };
bool compare(const Data& a, const Data& b) {
    if (a.len != b.len) return a.len > b.len;
    return a.mid > b.mid;
}
struct RESULT { int cnt = 0, IDs[5] = { 0, 0, 0, 0, 0 }; };
RESULT top5(int mTime) {
    RESULT ret = RESULT();
    process(mTime - time);
    time = mTime;
    vector<Data> v;
    for (auto& nx : hmap) v.push_back({ (int)w[nx.second].dq.size(), nx.first });
    int len = (int)v.size();
    if (len && len < 5) sort(v.begin(), v.end(), compare);
    else if (len >= 5) partial_sort(v.begin(), v.begin() + 5, v.end(), compare), len = 5;
    for (int i = 0; i < len; i++) ret.cnt = len, ret.IDs[i] = v[i].mid;
    return ret;
}
#endif // 1

```
