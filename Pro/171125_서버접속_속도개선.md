```cpp
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <string.h>
#include <time.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// extern void Init();
extern void init(int num);
extern void NewAccount(char id[11], char password[11], int defaulttime);
extern void Logout(char id[11]);
extern void Connect(char id[11], char password[11]);
extern int Tick();

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define MAX_ACCOUNT 50000
#define MAX_TIME	100000
#define MAX_USER	50000
#define MAX_TABLE	50007


typedef enum {
	INIT,
	NEWACCOUNT,
	LOGOUT,
	CONNECT,
	TICK
}STATE;

static int mSeed;

struct User {
	char id[11];
	char password[11];
	bool isLogout;
	int defaulttime;
	int logintime;  // 로그인상태를 유지할 수 있는 시간
	int logouttime;
};

struct ListNode {
	int id; // user배열의 인덱스 정보
	ListNode* next;
};

ListNode heap[1000000];
int hrp;

// 새로운 노드를 만들고 그 새로운 노드가 기존 head를 가르키게 하고 새로만들어진 노드의 주소를 리턴한다.
ListNode* appendListNode(int id, ListNode* oldhead) {
	//ListNode* node = new ListNode;
	ListNode* node = &heap[hrp++];
	node -> id = id;
	node -> next = oldhead;
	return node;
}

ListNode* head[MAX_TABLE];
ListNode* logoutUser[MAX_TIME];

unsigned long hash(const char* str)
{
	unsigned long hash = 5381;
	int c;
	while (c = *str++)
	{
		hash = (((hash << 5) + hash) + c) % MAX_TABLE;
	}
	return hash % MAX_TABLE;
}

User user[MAX_USER];

int userCount;

void mstrcpy(char dst[], const char src[])
{
	int c = 0;
	while ((dst[c] = src[c]) != 0) ++c;
}

int mstrcmp(char str1[], const char str2[])
{
	int c = 0;
	while (str1[c] != 0 && str1[c] == str2[c]) ++c;
	return str1[c] - str2[c];
}

static int mrand(int num)
{
	mSeed = mSeed * 1103515245 + 12345;
	return (((mSeed >> 16) & 0x7FFF) % num);
}

static void make_account(int cnt)
{
	for (int i = 0; i < cnt; i++) {
		int idl = 5 + mrand(6);
		for (int k = 0; k < idl; k++) {
			int ch = mrand(36);
			if (ch < 10) user[i].id[k] = ch + '0';
			else user[i].id[k] = ch - 10 + 'a';
		}
		user[i].id[idl] = '\0';

		int pal = 5 + mrand(6);
		for (int k = 0; k < pal; k++) {
			int ch = mrand(36);
			if (ch < 10) user[i].password[k] = ch + '0';
			else user[i].password[k] = ch - 10 + 'a';
		}
		user[i].password[pal] = '\0';

		int max_time = cnt;
		if (max_time > MAX_TIME) max_time = MAX_TIME;
		user[i].defaulttime = 1 + mrand(max_time);
	}
}

int currenttime;


static void init(int num)
{
	userCount = 0;
	currenttime = 0;
	hrp = 0;

	for (int i = 0; i < MAX_TABLE; i++)
	{
		head[i] = 0;
	}

	for (int i = 0; i < MAX_TIME; i++)
	{
		logoutUser[i] = 0;
	}

	memset(user, 0, sizeof(user));
	for (int i = 0; i < 20; i++) {
		user[i].isLogout = false;
	}
	make_account(num);
	for (int i = 0; i < num / 3; i++) {
		char id[11], password[11];
		int defaulttime;
		strcpy(id, user[i].id);
		strcpy(password, user[i].password);
		defaulttime = user[i].defaulttime;
		NewAccount(id, password, defaulttime);
	}
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	strcpy(user[userCount].id, id);
	strcpy(user[userCount].password, password);
	user[userCount].defaulttime = defaulttime;
	user[userCount].logouttime = currenttime + defaulttime;
	user[userCount].isLogout = false;

	int hashkey = hash(id);
	head[hashkey] = appendListNode(userCount, head[hashkey]);

	logoutUser[user[userCount].logouttime] = appendListNode(userCount,
		logoutUser[user[userCount].logouttime]);
	
	userCount++; // 사용자숫자 이기도 하고 새로운 사용자가 입력되어야할 Index
}


static int run()
{
	int ret = 1;
	int cmd, param1, param2, num, cmdcnt;

	char id[11], password[11];
	int defaulttime;

	scanf("%d %d %d %d", &cmd, &mSeed, &num, &cmdcnt);
	init(num);

	for (int i = 0; i < cmdcnt; i++) {
		scanf("%d", &cmd);
		if (cmd == NEWACCOUNT) {
			scanf("%d %d", &param1, &param2); // idindex, defaulttime
			strcpy(id, user[param1].id);
			strcpy(password, user[param1].password);
			defaulttime = param2;
			NewAccount(id, password, defaulttime);
		}
		else if (cmd == LOGOUT) {
			scanf("%d", &param1);
			strcpy(id, user[param1].id);
			Logout(id);
		}
		else if (cmd == CONNECT) {
			scanf("%d %d", &param1, &param2);
			strcpy(id, user[param1].id);
			strcpy(password, user[param2].password);
			Connect(id, password);
		}
		else if (cmd == TICK) {
			scanf("%d", &param1);
			int result = Tick();
			if (result != param1)
				ret = 0;
		}
	}

	return ret;
}

int main()
{
	clock_t start = clock();

	setbuf(stdout, NULL);
	freopen("sample_input_171125_서버접속.txt", "r", stdin);

	int T;
	scanf("%d", &T);

	// T = 1;
	for (int tc = 1; tc <= T; tc++)
	{
		int Score = 100;
		if (run() == 0)
			Score = 0;

		printf("#%d %d\n", tc, Score);
	}

	int result = (clock() - start) / (CLOCKS_PER_SEC / 1000);
	printf("\n>> Result: %d ms\n", result);
	return 0;
}

int getUserIdx(char id[11])
{
	int hashkey = hash(id);
	
	ListNode* temp = head[hashkey];
	while (temp != 0) {
		int i = temp->id;
		if (mstrcmp(user[i].id, id) == 0)
			return i;
		temp = temp->next;
	}

	/*for (int i = 0; i < userCount; i++)
	{
		if (mstrcmp(user[i].id, id) == 0)
			return i;
	}*/

	return -1;
}

void Logout(char id[11])
{
	/*id 에 해당 하는 계정의 서버 접속을 종료한다.
		서버에 login 되어 있지 않는 계정은 아무런 동작도 하지 않는다.*/
	int uIdx = getUserIdx(id);

	if (uIdx == -1)
		return;
	if (user[uIdx].isLogout)
		return;

	user[uIdx].isLogout = true;

}

void Connect(char id[11], char password[11])
{
	int uIdx = getUserIdx(id);
	if (uIdx == -1)
		return;
	if (user[uIdx].isLogout)
		return;
	if (strcmp(user[uIdx].password, password) != 0)
		return;
	user[uIdx].logouttime = currenttime + user[uIdx].defaulttime;
	//if(user[uIdx].logouttime <= 50000)
	logoutUser[user[uIdx].logouttime] = appendListNode(uIdx,
		logoutUser[user[uIdx].logouttime]);
}

int Tick()
{ 
	int logoutUserCount = 0;
	currenttime++;

	ListNode* temp = logoutUser[currenttime];

	while (temp != 0) {
		int i = temp->id;
	
		if (!user[i].isLogout && user[i].logouttime == currenttime)
		{
			user[i].isLogout = true;
			logoutUserCount++;
		}
		temp = temp->next;
	}

	/*for (int i = 0; i < userCount; i++)
	{
		if (user[i].isLogout)
			continue;
		
		if (user[i].logouttime == currenttime)
		{
			user[i].isLogout = true;
			logoutUserCount++;
		}
	}*/
	return logoutUserCount;
}

```
