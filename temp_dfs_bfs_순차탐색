from collections import deque
0 - 1 - 2
|   |   |
3 - 4 - 5
DFS / BFS (인접 배열)
graph_list = [
    [1, 3],     # node 0
    [0, 2, 4],  # node 1
    [1, 5],     # node 2
    [0, 4],     # node 3
    [1, 3, 5],  # node 4
    [3, 4],     # node 5
]
## DFS (recursion)
def dfs(graph, x, visited=[]):
    visited.append(x)
    for nx in sorted(graph[x]):
        if nx not in visited:
            visited = dfs(graph, nx)
    return visited

dfs(graph_list, 0)
## DFS (stack)
def dfs(graph, x):
    visited = [x]
    stack = deque([x])

    while stack:
        x = stack.pop()
        if x not in visited:
            visited.append(x)
        for nx in reversed(graph[x]):
            if nx not in visited:
                stack.append(nx)
    return visited

dfs(graph_list, 0)
## DFS (stack)
def dfs(graph, x):
    visited = [x]
    stack = deque([x])

    while stack:
        x = stack.pop()
        if x not in visited:
            visited.append(x)
        for nx in reversed(graph[x]):
            if nx not in visited:
                stack.append(nx)
    return visited

dfs(graph_list, 0)
DFS / BFS (인접 행렬)
graph_matrix = [
    [0, 1, 0, 1, 0, 0],     # node 0
    [0, 0, 1, 0, 1, 0],     # node 1
    [0, 1, 0, 0, 0, 1],     # node 2
    [1, 0, 0, 0, 1, 0],     # node 3
    [0, 1, 0, 1, 0, 1],     # node 4
    [0, 0, 0, 1, 1, 0],     # node 5
]
## DFS (recursion)
def dfs(matrix, x, visited=[]):
    visited.append(x)
    for nx in range(len(matrix[x])):
        if nx not in visited and matrix[x][nx] == 1:
            visited = dfs(matrix, nx)
    return visited

dfs(graph_matrix, 0)
## DFS (stack)
def dfs(matrix, x):
    visited = [x]
    stack = deque([x])

    while stack:
        x = stack.pop()
        if x not in visited:
            visited.append(x)
        for nx in reversed(range(len(matrix[x]))):
            if nx not in visited and matrix[x][nx] == 1:
                stack.append(nx)
    return visited

dfs(graph_matrix, 0)
## BFS (queue)
def bfs(matrix, x):
    visited = [x]
    queue = deque([x])

    while queue:
        x = queue.popleft()
        for nx in range(len(matrix[x])):
            if nx not in visited and matrix[x][nx] == 1:
                visited.append(nx)
                queue.append(nx)
    return visited

bfs(graph_matrix, 0)
DFS / BFS (완전탐색)
(0, 0) - (0, 1) - (0, 2)
  |        |        |
(1, 0) - (1, 1) - (1, 2)
  |        |        |
(2, 0) - (2, 1) - (2, 2)
grid = [[0, 0, 0], 
        [0, 0, 0], 
        [0, 0, 0]]

N, M = 3, 3
dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]
def dfs(grid, x, y, visited=[]):
    visited.append((x, y))
    for k in range(4):
        nx, ny = x + dx[k], y + dy[k]
    
        if 0 <= nx < N and 0 <= ny < M:
            if (nx, ny) not in visited:
                visited = dfs(grid, nx, ny)
    return visited

dfs(grid, 0, 0) # [(0, 0), (1, 0), (2, 0), (2, 1), (1, 1), (0, 1), (0, 2), (1, 2), (2, 2)]
def dfs(grid, x, y):
    visited = [(x, y)]
    queue = deque([(x, y)])
    while queue:
        x, y = queue.pop()
        if (x, y) not in visited:
            visited.append((x, y))
        for k in range(4):
            nx, ny = x + dx[k], y + dy[k]
            if 0 <= nx < N and 0 <= ny < M:
                if (nx, ny) not in visited:
                    queue.append((nx, ny))
    return visited

dfs(grid, 0, 0)
def bfs(grid, x, y):
    visited = [(x, y)]
    queue = deque([(x, y)])
    while queue:
        x, y = queue.popleft()
        for k in range(4):
            nx, ny = x + dx[k], y + dy[k]
            if 0 <= nx < N and 0 <= ny < M:
                if (nx, ny) not in visited:
                    visited.append((nx, ny))
                    queue.append((nx, ny))
    return visited

bfs(grid, 0, 0)
